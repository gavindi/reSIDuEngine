// reSIDuEngine - C++ implementation of the Commodore 64 SID chip

/*
 * Copyright (c) 2026, Gavin Graham <gavindi@gmail.com>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

#ifndef RESIDUENGINE_H
#define RESIDUENGINE_H

#include <cstdint>
#include <array>
#include <cmath>

namespace reSIDuEngine
{

/**
 * Number of audio channels (voices) in the SID chip.
 * The MOS 6581/8580 SID chip has exactly 3 independent voices, each capable of
 * generating waveforms with independent frequency, waveform type, and ADSR envelope.
 * This implementation supports a single SID chip only.
 */
constexpr int SID_CHANNELS = 3;

/**
 * CPU clock frequency for PAL Commodore 64 systems.
 * The PAL C64 uses a 985248 Hz CPU clock (approximately 0.985 MHz). This is slightly
 * slower than NTSC systems which run at ~1.023 MHz. This clock rate affects how fast
 * the SID chip's internal counters advance, which in turn affects pitch and timing.
 */
constexpr double C64_PAL_CPUCLK = 985248.0;  // Hz

/**
 * Frame rate for PAL video systems.
 * PAL systems refresh at 50 frames per second (compared to NTSC's ~60 fps).
 * This affects timing for music playback that relies on frame-synchronized updates.
 */
constexpr double PAL_FRAMERATE = 50.0;

// ============================================================================
// Control Register Bit Masks
// ============================================================================
// The SID chip uses bit-packed control registers where individual bits enable
// or disable specific features. These masks allow us to test and manipulate
// those individual bits.

/**
 * Gate bit in the voice control register.
 * When set (1), this bit triggers the Attack phase of the ADSR envelope.
 * When cleared (0), it triggers the Release phase. This is how notes are
 * started and stopped - setting the gate "presses" a key, clearing it "releases" it.
 */
constexpr uint8_t GATE_BITMASK = 0x01;

/**
 * Sync bit in the voice control register.
 * When set, this voice's oscillator is synchronized (reset to zero) whenever
 * the previous voice's oscillator wraps around from maximum to minimum. This
 * creates hard-sync effects useful for creating aggressive, metallic timbres.
 * Voice 1 syncs to Voice 3, Voice 2 syncs to Voice 1, Voice 3 syncs to Voice 2.
 */
constexpr uint8_t SYNC_BITMASK = 0x02;

/**
 * Ring modulation bit in the voice control register.
 * When set, the triangle waveform output is ring-modulated (XOR operation) with
 * the MSB of the previous voice's phase accumulator. This creates bell-like,
 * metallic sounds. Only affects triangle waveform output.
 * Voice 1 is modulated by Voice 3, Voice 2 by Voice 1, Voice 3 by Voice 2.
 */
constexpr uint8_t RING_BITMASK = 0x04;

/**
 * Test bit in the voice control register.
 * When set, this bit halts the oscillator and resets it to zero. It also disables
 * the LFSR (noise generator) from advancing. This was primarily used for testing
 * the chip during manufacturing, but can be used to hold a waveform at a specific
 * phase or to synchronize oscillators in creative ways.
 */
constexpr uint8_t TEST_BITMASK = 0x08;

/**
 * Triangle waveform selection bit.
 * When set, enables the triangle waveform generator for this voice. The triangle
 * wave is a linear ramp up then linear ramp down, creating a mellow tone rich in
 * odd harmonics. Can be combined with other waveforms for complex timbres.
 */
constexpr uint8_t TRI_BITMASK = 0x10;

/**
 * Sawtooth waveform selection bit.
 * When set, enables the sawtooth waveform generator for this voice. The sawtooth
 * is a linear ramp from minimum to maximum that sharply drops back to minimum,
 * creating a bright, buzzy tone rich in all harmonics. Can be combined with
 * other waveforms for complex timbres.
 */
constexpr uint8_t SAW_BITMASK = 0x20;

/**
 * Pulse (rectangle) waveform selection bit.
 * When set, enables the pulse waveform generator for this voice. The pulse wave
 * is a square wave with variable duty cycle (pulse width) controlled by dedicated
 * pulse width registers. Narrow pulses sound thin and reedy, while 50% duty cycle
 * produces a hollow square wave. Can be combined with other waveforms.
 */
constexpr uint8_t PULSE_BITMASK = 0x40;

/**
 * Noise waveform selection bit.
 * When set, enables the noise generator for this voice. The noise is generated by
 * a 23-bit Linear Feedback Shift Register (LFSR) that produces a pseudo-random
 * sequence. Used for percussion, sound effects, and textured tones. Should generally
 * not be combined with other waveforms (produces silence or unpredictable output).
 */
constexpr uint8_t NOISE_BITMASK = 0x80;

// ============================================================================
// ADSR Envelope State Machine Bit Masks
// ============================================================================
// The ADSR envelope generator is implemented as a state machine. These bits
// track which phase the envelope is currently in.

/**
 * Hold-at-zero state bit for ADSR envelope.
 * This internal state bit indicates that the envelope has decayed/released all
 * the way to zero and should remain there until a new gate event occurs. This
 * prevents the envelope from going negative or oscillating around zero.
 */
constexpr uint8_t HOLDZERO_BITMASK = 0x10;

/**
 * Decay/Sustain phase state bit for ADSR envelope.
 * When set, indicates the envelope is in the Decay or Sustain phase (after Attack
 * has completed). During Decay, the envelope decreases toward the Sustain level.
 * Once it reaches Sustain level, it holds there as long as Gate remains high.
 */
constexpr uint8_t DECAYSUSTAIN_BITMASK = 0x40;

/**
 * Attack phase state bit for ADSR envelope.
 * When set, indicates the envelope is in the Attack phase - ramping up from
 * its current level to maximum (255). This phase begins when the Gate bit
 * transitions from 0 to 1 (note-on event).
 */
constexpr uint8_t ATTACK_BITMASK = 0x80;

// ============================================================================
// Filter Configuration Bit Masks
// ============================================================================
// The SID chip contains a multi-mode analog filter that can process voice
// signals in lowpass, bandpass, or highpass modes (or combinations thereof).

/**
 * Lowpass filter enable bit.
 * When set in the filter mode/volume register, routes the filtered signal through
 * a lowpass filter before output. Lowpass filters attenuate high frequencies while
 * passing low frequencies, creating warm, muffled tones. Can be combined with
 * bandpass and/or highpass for complex filter responses.
 */
constexpr uint8_t LOWPASS_BITMASK = 0x10;

/**
 * Bandpass filter enable bit.
 * When set in the filter mode/volume register, routes the filtered signal through
 * a bandpass filter before output. Bandpass filters allow a range of frequencies
 * around the cutoff to pass while attenuating frequencies above and below, creating
 * nasal, vocal-like tones. Can be combined with lowpass and/or highpass.
 */
constexpr uint8_t BANDPASS_BITMASK = 0x20;

/**
 * Highpass filter enable bit.
 * When set in the filter mode/volume register, routes the filtered signal through
 * a highpass filter before output. Highpass filters attenuate low frequencies while
 * passing high frequencies, creating thin, bright tones. Can be combined with
 * lowpass and/or bandpass for complex filter responses.
 */
constexpr uint8_t HIGHPASS_BITMASK = 0x40;

/**
 * Voice 3 disable bit (mute Voice 3 output).
 * When set, Voice 3's output is disconnected from the audio output path. However,
 * Voice 3 continues to run internally and can still be used to modulate other voices
 * via sync or ring modulation. This feature is often used to create "silent" modulation
 * sources or to use Voice 3 as a low-frequency oscillator (LFO) without hearing it.
 */
constexpr uint8_t OFF3_BITMASK = 0x80;

/**
 * External audio input routing bit (filter routing register).
 * When set in the filter routing register (0xD417), the external audio input (EXT IN)
 * is routed through the filter. When cleared, EXT IN is mixed directly with the output.
 * This allows external audio sources (like cassette tapes or digitized samples) to be
 * processed by the SID's filter or mixed with SID-generated sounds.
 */
constexpr uint8_t EXTIN_BITMASK = 0x08;

/**
 * SID chip model enumeration.
 * The SID chip was produced in two major revisions with audibly different characteristics:
 * - MOS6581: Original version (1982-1987), warmer sound, different filter characteristics
 * - MOS8580: Revised version (1987+), brighter sound, more consistent filter behavior
 */
enum SIDModel
{
    MOS6581 = 6581,  // Original SID chip with warmer, more analog character
    MOS8580 = 8580   // Revised SID chip with brighter, more digital sound
};

/**
 * reSIDuEngine - SID chip emulator engine
 *
 *
 * This class emulates the MOS Technology 6581/8580 Sound Interface Device (SID),
 * the programmable sound generator chip used in the Commodore 64 computer.
 *
 * The SID chip features:
 * - 3 independent oscillators (voices) with multiple waveforms
 * - 4 waveform types per voice: triangle, sawtooth, pulse (variable width), and noise
 * - ADSR envelope generator for each voice
 * - Multi-mode resonant filter (lowpass, bandpass, highpass)
 * - Ring modulation and hard sync between voices
 * - Support for combined waveforms (mixing waveform types on a single voice)
 *
 * This implementation uses:
 * - Double-precision floating-point phase accumulators to avoid quantization noise
 * - Band-limited waveform synthesis to reduce aliasing artifacts
 * - Per-sample processing for accurate emulation of SID behavior
 * - Configurable sample rate for flexibility
 * - Support for both 6581 and 8580 chip models with their respective characteristics
 */
class SID
{
public:
    /**
     * Construct a new SID emulator instance.
     *
     * Initializes the SID chip emulation with the specified sample rate and chip model.
     * The constructor sets up all internal state including:
     * - Waveform generation tables (including combined waveform lookup tables)
     * - ADSR envelope timing arrays based on the sample rate
     * - Filter coefficient calculations for the specified sample rate
     * - All voice state (phase accumulators, envelope counters, LFSR states)
     *
     * @param sampleRate The audio output sample rate in Hz (e.g., 44100, 48000).
     *                   Higher sample rates provide better audio quality but require
     *                   more CPU processing. Recommended: 44100 or 48000 Hz.
     * @param model The SID chip model to emulate (MOS6581 or MOS8580).
     *              Defaults to MOS8580. The chip model affects filter characteristics,
     *              combined waveform behavior, and overall tonal character.
     */
    SID(double sampleRate, SIDModel model = MOS8580);

    /**
     * Destructor for the SID emulator.
     * Cleans up any resources allocated by the SID instance.
     */
    ~SID();

    /**
     * Reset the SID chip to its power-on state.
     *
     * Clears all SID registers, resets all voices to silent state, clears all
     * envelopes, resets phase accumulators, and initializes filter state.
     * This is equivalent to power-cycling the chip. Use this when starting
     * playback of a new song or when you need to ensure a clean slate.
     */
    void reset();

    /**
     * Write a byte value to a SID register.
     *
     * The SID chip is memory-mapped in the Commodore 64 address space. This method
     * emulates writing to those memory locations. Register writes control all aspects
     * of sound generation:
     * - Voice frequency (registers 0x00-0x01, 0x07-0x08, 0x0E-0x0F)
     * - Pulse width (registers 0x02-0x03, 0x09-0x0A, 0x10-0x11)
     * - Voice control: waveform, gate, sync, ring mod (registers 0x04, 0x0B, 0x12)
     * - ADSR envelope parameters (registers 0x05-0x06, 0x0C-0x0D, 0x13-0x14)
     * - Filter cutoff frequency (registers 0x15-0x16)
     * - Filter resonance and routing (register 0x17)
     * - Filter mode and master volume (register 0x18)
     *
     * @param addr Register address or offset. Can be either:
     *             - Full address (0xD400-0xD7FF, 0xDE00-0xDFFF) - legacy compatibility
     *             - Register offset (0-31) - reSIDfp API compatibility
     * @param value The 8-bit value to write to the register. Different registers
     *              interpret this value differently (frequency, volume, flags, etc.).
     */
    void write(int addr, unsigned char value);

    /**
     * Read a byte value from a SID register.
     *
     * Most SID registers are write-only, but a few can be read back:
     * - Register 0x1B (offset 27): Oscillator 3 output (upper 8 bits of Voice 3's waveform)
     * - Register 0x1C (offset 28): Envelope 3 output (current ADSR envelope level for Voice 3)
     * These read-back capabilities were often used for random number generation
     * (oscillator 3) or for synchronizing game events to music (envelope 3).
     *
     * @param addr Register address or offset. Can be either:
     *             - Full address (0xD400-0xD7FF) - legacy compatibility
     *             - Register offset (0-31) - reSIDfp API compatibility
     * @return The 8-bit value currently in the specified register. Returns 0
     *         for write-only registers.
     */
    unsigned char read(int addr);

    /**
     * Clock the SID chip and generate audio samples (reSIDfp API compatible).
     *
     * This is the main processing function that advances the SID emulation by
     * the specified number of CPU cycles and generates the corresponding audio
     * samples into the provided buffer.
     *
     * @param cycles Number of CPU cycles to advance the emulation
     * @param buf Buffer to receive 16-bit signed audio samples. Must be large enough
     *            to hold at least (cycles / clkRatio) samples. If NULL, samples are
     *            generated but not stored (same as clockSilent).
     * @return Number of audio samples generated and written to the buffer
     */
    int clock(unsigned int cycles, short *buf);

    /**
     * Generate one audio sample by advancing the SID emulation by one sample period.
     *
     * Convenience method for single-sample generation. This performs one complete
     * emulation step and returns a floating-point sample.
     *
     * @return A floating-point audio sample in the approximate range of -1.0 to +1.0.
     *         The exact range depends on how many voices are active and their levels.
     *         With 3 voices at maximum, output can exceed ±1.0 (typically reaching
     *         about ±1.5), so you may want to apply limiting or normalization.
     */
    float clockSample();

    /**
     * Process the SID chip and return its mixed output.
     *
     * This internal method handles the emulation of the SID chip (3 voices).
     * It's called by clock() and performs:
     * - ADSR envelope generation for all 3 voices
     * - Waveform generation for all 3 voices
     * - Voice routing (to filter or direct output)
     * - Filter processing (lowpass, bandpass, highpass)
     * - Voice mixing
     *
     * @return The mixed and filtered audio output as a floating-point value,
     *         scaled by the master volume register.
     */
    float processSID();

    /**
     * Set the SID chip model to emulate.
     *
     * Changes the chip model between MOS6581 (original) and MOS8580 (revised).
     * This affects:
     * - Filter cutoff frequency range and behavior
     * - Filter resonance characteristics
     * - Combined waveform output (6581 vs 8580 have different analog behaviors)
     * - Overall tonal character
     *
     * You can call this at any time, even during playback, though it may cause
     * audible artifacts. Some SID music is composed specifically for one chip
     * model and may sound wrong on the other.
     *
     * @param model The chip model to emulate (MOS6581 or MOS8580).
     */
    void setModel(SIDModel model);

    /**
     * Get the currently configured SID chip model.
     *
     * @return The current chip model being emulated (MOS6581 or MOS8580).
     */
    SIDModel getModel() const { return sidModel; }

    /**
     * Set the master volume multiplier for all SID output.
     *
     * This is an additional volume control on top of the SID's built-in volume
     * register. Useful for adjusting the overall loudness of the emulation to
     * match other audio sources in your application. Does not affect the SID's
     * internal volume register (0xD418 bits 0-3).
     *
     * @param vol Volume multiplier (1.0 = normal, 0.5 = half volume, 2.0 = double volume).
     *            Values outside 0.0-1.0 may cause clipping.
     */
    void setVolume(float vol) { volume = vol; }

    /**
     * Set the C64 CPU clock frequency in Hz.
     *
     * The CPU clock rate affects how fast the SID's internal counters advance,
     * which directly affects pitch and timing. Standard values:
     * - PAL systems: 985248 Hz (default)
     * - NTSC systems: 1022727 Hz
     *
     * Changing this will alter the pitch of all playing notes. Use this to switch
     * between PAL and NTSC tuning, or to implement speed/pitch effects.
     *
     * @param hz The CPU clock frequency in Hz. After changing this, the internal
     *           clock ratio is automatically recalculated to maintain proper timing.
     */
    void setClock(double hz) { cpuClock = hz; updateClockRatio(); }

    /**
     * Set the frame rate for frame-synchronized timing.
     *
     * Some SID music players rely on frame-based timing (e.g., calling the music
     * player routine 50 times per second on PAL systems). This sets the expected
     * frame rate for such timing calculations. Standard values:
     * - PAL: 50 Hz (default)
     * - NTSC: 60 Hz (approximately 59.826 Hz to be precise)
     *
     * @param hz The frame rate in Hz.
     */
    void setFramerate(double hz);

    // ========================================================================
    // reSIDfp API Compatibility Methods
    // ========================================================================

    /**
     * Set sampling parameters (reSIDfp API compatibility).
     *
     * This method provides compatibility with the reSIDfp API by allowing
     * configuration of clock frequency and sample rate. The method parameter
     * is ignored in this implementation as we always use per-sample processing.
     *
     * @param clockFrequency CPU clock frequency in Hz (985248 for PAL, 1022730 for NTSC)
     * @param method Sampling method (ignored - reSIDuEngine always uses sample-based)
     * @param samplingFrequency Audio output sample rate in Hz (e.g., 44100)
     * @param highestAccurateFrequency Passband frequency (ignored in this implementation)
     */
    void setSamplingParameters(double clockFrequency, int method,
                              double samplingFrequency, double highestAccurateFrequency = 0);

    /**
     * Clock the SID chip silently without generating audio output.
     *
     * Advances the SID emulation state (envelopes, oscillators, etc.) without
     * actually computing audio samples. Useful for fast-forwarding or seeking
     * in SID playback.
     *
     * @param cycles Number of CPU cycles to advance (at the configured clock rate)
     */
    void clockSilent(unsigned int cycles);

    /**
     * Enable or disable filter emulation (reSIDfp API compatibility).
     *
     * When disabled, the filter is bypassed and voices pass through unfiltered.
     * This can be useful for debugging or performance optimization.
     *
     * @param enable True to enable filter, false to disable
     */
    void enableFilter(bool enable);

    /**
     * Mute or unmute a specific voice (reSIDfp API compatibility).
     *
     * Allows individual voices to be silenced without affecting their
     * internal state (oscillators and envelopes continue running).
     *
     * @param channel Voice number (0-2)
     * @param enable True to mute the voice, false to unmute
     */
    void mute(int channel, bool enable);

    /**
     * Set the SID chip model (reSIDfp API name).
     *
     * This is an alias for setModel() to provide exact reSIDfp API compatibility.
     * Changes the chip model between MOS6581 (original) and MOS8580 (revised).
     *
     * @param model The chip model to emulate (MOS6581 or MOS8580)
     */
    void setChipModel(SIDModel model) { setModel(model); }

    /**
     * Get the currently configured SID chip model (reSIDfp API name).
     *
     * This is an alias for getModel() to provide exact reSIDfp API compatibility.
     *
     * @return The current chip model being emulated (MOS6581 or MOS8580)
     */
    SIDModel getChipModel() const { return getModel(); }

    /**
     * Input external audio signal (EXT IN) - reSIDfp API compatibility.
     *
     * The SID chip has an external audio input (EXT IN) that can be mixed
     * with the SID's own output or routed through the filter. This method
     * allows injection of external 16-bit audio samples.
     *
     * Note: This implementation stores the sample for mixing in the next
     * processSID() call. The sample is consumed after use.
     *
     * @param value 16-bit signed audio sample to inject (-32768 to +32767)
     */
    void input(int value);

private:
    // ========================================================================
    // Private Helper Methods
    // ========================================================================

    /**
     * Initialize all SID chip state to power-on defaults.
     *
     * Clears all memory-mapped registers, resets all voice state (phase accumulators,
     * envelopes, noise LFSRs), and initializes filter state. Called by the constructor
     * and by reset().
     */
    void initSID();

    /**
     * Recalculate the clock ratio when sample rate or CPU clock changes.
     *
     * The clock ratio is how many CPU cycles occur per audio sample. This ratio
     * is critical for maintaining correct pitch - it determines how much to advance
     * the phase accumulators on each sample. Also recalculates the frame sample period.
     */
    void updateClockRatio();

    /**
     * Generate a combined waveform lookup table.
     *
     * When multiple waveform bits are set simultaneously on the SID, the waveforms
     * don't simply add or mix - they interact in complex ways due to the analog
     * circuitry (open-drain drivers, FET switches causing bit-fighting). This function
     * models that analog behavior by simulating how neighboring bits in the waveform
     * DAC affect each other through resistive/capacitive coupling.
     *
     * @param waveformArray Reference to the 4096-entry array to fill with combined waveform data.
     *                      4096 entries covers all possible 12-bit waveform values.
     * @param bitmul Multiplier for bit influence strength. Higher values mean stronger
     *               interaction between bits.
     * @param bitstrength Exponential decay factor for bit influence over distance.
     *                    Higher values mean bits affect their neighbors less.
     * @param threshold Threshold level above which a bit is considered "on" in the output.
     *                  This simulates the switching threshold of the analog circuitry.
     */
    void createCombinedWF(std::array<uint16_t, 4096>& waveformArray,
                         double bitmul, double bitstrength, double threshold);

    /**
     * Look up and interpolate a combined waveform value.
     *
     * Retrieves a value from one of the combined waveform lookup tables and
     * applies simple interpolation with the previous sample to smooth transitions.
     * Also handles the different behavior between 6581 and 8580 chips for certain
     * waveform combinations.
     *
     * @param voiceIndex The voice number (0-2) requesting the waveform value.
     * @param waveformArray Reference to the combined waveform lookup table to use.
     * @param index The 12-bit waveform index (derived from phase accumulator).
     * @param differ6581 If true, applies 6581-specific behavior (halving certain waveforms).
     * @return The combined waveform output value as a 16-bit unsigned integer.
     */
uint16_t combinedWF(int voiceIndex, const std::array<uint16_t, 4096>& waveformArray,
                        int index, bool differ6581);

    /**
     * Get measured combined waveform value without artificial interpolation.
     * Direct lookup from tables based on real SID chip measurements.
     * Follows libsidplayfp approach for accurate analog behavior.
     */
    uint16_t getMeasuredCombinedWF(int voiceIndex, int index, uint8_t waveformCtrl);

    /**
     * Get measured combined waveform value without artificial interpolation.
     * Direct lookup from tables based on real SID chip measurements.
     * Follows libsidplayfp approach for accurate analog behavior.
     */

    // ========================================================================
    // Member Variables - Clock and Sample Rate
    // ========================================================================

    double sampleRate;           ///< Audio output sample rate in Hz (e.g., 44100.0)
    double cpuClock;             ///< C64 CPU clock frequency in Hz (default: 985248.0 for PAL)
    double frameRate;            ///< Frame rate in Hz for frame-synchronized playback (default: 50.0 for PAL)
    double clkRatio;             ///< CPU cycles per audio sample (cpuClock / sampleRate)
    double frameSamplePeriod;    ///< Audio samples per frame (sampleRate / frameRate)
    SIDModel sidModel;           ///< Currently emulated chip model (6581 or 8580)
    float volume;                ///< Master volume multiplier (1.0 = normal)

    // ========================================================================
    // Member Variables - reSIDfp API Compatibility
    // ========================================================================

    bool filterEnabled;                         ///< Filter enable/disable flag (reSIDfp compatibility)
    std::array<bool, SID_CHANNELS> voiceMuted;  ///< Per-voice mute flags (reSIDfp compatibility)
    int externalInput;                          ///< External audio input sample (EXT IN, reSIDfp compatibility)

    // ========================================================================
    // Member Variables - Memory
    // ========================================================================

    /**
     * SID register memory (32 bytes: $D400-$D41F).
     * The SID chip has exactly 32 registers at addresses 0xD400-0xD41F.
     * We store only these registers without mirrors or the full memory map.
     */
    std::array<uint8_t, 32> SIDRegister;

    // ========================================================================
    // Member Variables - ADSR Envelope State (per voice)
    // ========================================================================

    std::array<uint8_t, SID_CHANNELS> adsrState;   ///< ADSR state machine flags (ATTACK/DECAYSUSTAIN/HOLDZERO bits)
    std::array<float, SID_CHANNELS> rateCounter;   ///< ADSR rate counter (counts up to period)
    std::array<int, SID_CHANNELS> envelopeCounter;          ///< Current envelope level (0-255)
    std::array<int, SID_CHANNELS> exponentCounter;          ///< Exponential decay counter (for logarithmic release)
    std::array<uint8_t, SID_CHANNELS> previousSR;      ///< Previous sustain/release value (for detecting changes)

    // ========================================================================
    // Member Variables - Waveform Generation State (per voice)
    // ========================================================================

    /**
     * Phase accumulator for each voice (24-bit precision stored as double).
     * The phase accumulator is the heart of the oscillator - it's essentially a counter
     * that increments by the frequency value each CPU cycle and wraps around at 0xFFFFFF.
     * The upper bits of this accumulator are used to generate waveforms.
     * We use double instead of uint32_t to preserve fractional precision and avoid
     * quantization noise that would cause graininess at certain frequencies.
     */
    std::array<double, SID_CHANNELS> phaseAccumulator;

    /**
     * Previous phase accumulator value for each voice.
     * Stored to detect wraparound (for hard sync) and MSB transitions (for noise clocking).
     * Also stored as double to maintain precision for band-limiting calculations.
     */
    std::array<double, SID_CHANNELS> previousAccumulator;

    std::array<uint32_t, SID_CHANNELS> noiseLFSR;           ///< 23-bit LFSR state for noise generation (per voice)
    std::array<uint16_t, SID_CHANNELS> previousWFOut;       ///< Previous waveform output (for waveform 00 floating DAC emulation)
    std::array<uint16_t, SID_CHANNELS> previousWaveData;    ///< Previous combined waveform value (for interpolation)

    std::array<uint8_t, SID_CHANNELS> sourceMSBrise;  ///< Detected MSB rising edge (for sync, one per voice)
    std::array<uint32_t, SID_CHANNELS> sourceMSB;     ///< Previous voice's MSB (for ring mod/sync, one per voice)

    // ========================================================================
    // Member Variables - Filter State
    // ========================================================================

    float previousLowpass;                  ///< Previous lowpass filter output
    float previousBandpass;                 ///< Previous bandpass filter output
    double cutoffRatio8580;             ///< Precalculated cutoff coefficient for 8580 chip model
    double cutoffRatio6581;             ///< Precalculated cutoff coefficient for 6581 chip model

    // ========================================================================
    // Member Variables - Combined Waveform Lookup Tables
    // ========================================================================
    // These tables store precalculated combined waveform values for when multiple
    // waveform bits are enabled simultaneously. Each table has 4096 entries
    // corresponding to all possible 12-bit waveform values.

    std::array<uint16_t, 4096> triSaw8580;      ///< Triangle + Sawtooth combined waveform (8580-style)
    std::array<uint16_t, 4096> pulseSaw8580;    ///< Pulse + Sawtooth combined waveform (8580-style)
    std::array<uint16_t, 4096> pulseTriSaw8580; ///< Pulse + Triangle + Sawtooth combined waveform (8580-style)

    // ========================================================================
    // Member Variables - ADSR Timing Lookup Tables
    // ========================================================================

    /**
     * ADSR period lookup table (in audio samples).
     * There are 16 possible rate values (4-bit selection), each with a different
     * period (how long between envelope counter updates). These periods are scaled
     * based on the sample rate. Longer periods = slower envelope stages.
     */
    std::array<float, 16> adsrPeriods;

    /**
     * ADSR step size lookup table.
     * Determines how much to increment/decrement the envelope counter when the
     * period expires. Most rates use step=1, but very fast attack rates may use
     * larger steps to reach maximum quickly.
     */
    std::array<int, 16> adsrStep;

    /**
     * ADSR exponential decay table.
     * The SID's decay and release stages are exponential (logarithmic), not linear.
     * This is achieved by slowing down the envelope counter as it decreases. This
     * table contains prescaler values that determine how many times the period must
     * expire before the envelope counter actually decrements, based on the current
     * envelope level. Higher values = slower decay at lower volumes, creating the
     * exponential curve.
     */
    std::array<int, 256> adsrExptable;

    // ========================================================================
    // Static Constants - Filter and Volume
    // ========================================================================

    /**
     * Filter routing bitmask lookup table.
     * Maps each voice (0-2) to its corresponding bit in the filter routing register.
     * Voice 0 uses bit 0 (value 1), voice 1 uses bit 1 (value 2), voice 2 uses bit 2 (value 4).
     * This allows the filter routing register to independently enable/disable filtering
     * for each of the 3 voices.
     */
    static constexpr std::array<int, SID_CHANNELS> FILTSW = {1, 2, 4};
};

} // namespace reSIDuEngine

#endif // RESIDUENGINE_H
